///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "StdAfx.h"


#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && (defined(__i386__) || defined(__x86_64__)) \
                         && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: File / Misc
// Short Description: Get all image files under the given path 
void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles);
// Local procedures 
// Chapter: 自动建模
// Short Description: 自动建模 
void InnerHalconAutoCreateAlgMode (HObject ho_hCheckImg, HObject *ho_hShowReg, HObject *ho_hModelImg, 
    HObject *ho_hModelReg, HTuple hv_htParamVaule, HTuple hv_htResolution, HTuple hv_htHalconHandle, 
    HTuple *hv_htParamVauleNew, HTuple *hv_htCheckResultCode, HTuple *hv_htHalconHandleNew, 
    HTuple *hv_htState);
void InnerHalconAutoLearnAlgMode (HObject ho_hModelImg, HObject ho_hCheckImg, HObject *ho_hModelImgNew, 
    HTuple *hv_htState);
void InnerHalconInitHandle (HTuple hv_ParamVaule, HTuple hv_HalconHandle, HTuple *hv_HalconHandleNew, 
    HTuple *hv_htState);
void InnerHalconReadHtParam (HTuple hv_ImgChannels, HTuple *hv_ParamProp, HTuple *hv_ParamName, 
    HTuple *hv_ParamVaule, HTuple *hv_ParamMeaning, HTuple *hv_ParamType, HTuple *hv_ParamMinVaule, 
    HTuple *hv_ParamMaxVaule, HTuple *hv_ParamStep, HTuple *hv_ParamChildNames, HTuple *hv_htState);
// Chapter: 内部检测
// Short Description: 内部检测 
void InnerHalconSingleCheck (HObject ho_hCheckImg, HObject ho_hModelImg, HObject ho_hModelReg, 
    HObject *ho_hShowReg, HObject *ho_hErrorReg, HTuple hv_htParamVaule, HTuple hv_htResolution, 
    HTuple hv_htHalconHandle, HTuple hv_htExpectedCode, HTuple *hv_htErrorInfor, 
    HTuple *hv_htCheckResultCode, HTuple *hv_htState);

// Procedures 
// External procedures 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_GenParamName, hv_GenParamValue;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Column: The column coordinate of the desired text position
  //   A tuple of values is allowed to display text at different
  //   positions.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically...
  //   - if |Row| == |Column| == 1: for each new textline
  //   = else for each text position.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow
  //       otherwise -> use given string as color string for the shadow color
  //
  //It is possible to display multiple text strings in a single call.
  //In this case, some restrictions apply:
  //- Multiple text positions can be defined by specifying a tuple
  //  with multiple Row and/or Column coordinates, i.e.:
  //  - |Row| == n, |Column| == n
  //  - |Row| == n, |Column| == 1
  //  - |Row| == 1, |Column| == n
  //- If |Row| == |Column| == 1,
  //  each element of String is display in a new textline.
  //- If multiple positions or specified, the number of Strings
  //  must match the number of positions, i.e.:
  //  - Either |String| == n (each string is displayed at the
  //                          corresponding position),
  //  - or     |String| == 1 (The string is displayed n times).
  //
  //
  //Convert the parameters for disp_text.
  if (0 != (HTuple(hv_Row==HTuple()).TupleOr(hv_Column==HTuple())))
  {
    return;
  }
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  //
  //Convert the parameter Box to generic parameters.
  hv_GenParamName = HTuple();
  hv_GenParamValue = HTuple();
  if (0 != ((hv_Box.TupleLength())>0))
  {
    if (0 != (HTuple(hv_Box[0])==HTuple("false")))
    {
      //Display no box
      hv_GenParamName = hv_GenParamName.TupleConcat("box");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[0])!=HTuple("true")))
    {
      //Set a color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
    }
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      //Display no shadow.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
      hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
    }
    else if (0 != (HTuple(hv_Box[1])!=HTuple("true")))
    {
      //Set a shadow color other than the default.
      hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
      hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
    }
  }
  //Restore default CoordSystem behavior.
  if (0 != (hv_CoordSystem!=HTuple("window")))
  {
    hv_CoordSystem = "image";
  }
  //
  if (0 != (hv_Color==HTuple("")))
  {
    //disp_text does not accept an empty string for Color.
    hv_Color = HTuple();
  }
  //
 /* DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color, 
      hv_GenParamName, hv_GenParamValue);*/
  return;
}

// Chapter: File / Misc
// Short Description: Get all image files under the given path 
void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ImageDirectoryIndex, hv_ImageFilesTmp;
  HTuple  hv_CurrentImageDirectory, hv_HalconImages, hv_OS;
  HTuple  hv_Directories, hv_Index, hv_Length, hv_NetworkDrive;
  HTuple  hv_Substring, hv_FileExists, hv_AllFiles, hv_i;
  HTuple  hv_Selection;

  //This procedure returns all files in a given directory
  //with one of the suffixes specified in Extensions.
  //
  //Input parameters:
  //ImageDirectory: Directory or a tuple of directories with images.
  //   If a directory is not found locally, the respective directory
  //   is searched under %HALCONIMAGES%/ImageDirectory.
  //   See the Installation Guide for further information
  //   in case %HALCONIMAGES% is not set.
  //Extensions: A string tuple containing the extensions to be found
  //   e.g. ['png','tif',jpg'] or others
  //If Extensions is set to 'default' or the empty string '',
  //   all image suffixes supported by HALCON are used.
  //Options: as in the operator list_files, except that the 'files'
  //   option is always used. Note that the 'directories' option
  //   has no effect but increases runtime, because only files are
  //   returned.
  //
  //Output parameter:
  //ImageFiles: A tuple of all found image file names
  //
  if (0 != (HTuple(HTuple(hv_Extensions==HTuple()).TupleOr(hv_Extensions==HTuple(""))).TupleOr(hv_Extensions==HTuple("default"))))
  {
    hv_Extensions.Clear();
    hv_Extensions[0] = "ima";
    hv_Extensions[1] = "tif";
    hv_Extensions[2] = "tiff";
    hv_Extensions[3] = "gif";
    hv_Extensions[4] = "bmp";
    hv_Extensions[5] = "jpg";
    hv_Extensions[6] = "jpeg";
    hv_Extensions[7] = "jp2";
    hv_Extensions[8] = "jxr";
    hv_Extensions[9] = "png";
    hv_Extensions[10] = "pcx";
    hv_Extensions[11] = "ras";
    hv_Extensions[12] = "xwd";
    hv_Extensions[13] = "pbm";
    hv_Extensions[14] = "pnm";
    hv_Extensions[15] = "pgm";
    hv_Extensions[16] = "ppm";
    //
  }
  (*hv_ImageFiles) = HTuple();
  //Loop through all given image directories.
  {
  HTuple end_val27 = (hv_ImageDirectory.TupleLength())-1;
  HTuple step_val27 = 1;
  for (hv_ImageDirectoryIndex=0; hv_ImageDirectoryIndex.Continue(end_val27, step_val27); hv_ImageDirectoryIndex += step_val27)
  {
    hv_ImageFilesTmp = HTuple();
    hv_CurrentImageDirectory = HTuple(hv_ImageDirectory[hv_ImageDirectoryIndex]);
    if (0 != (hv_CurrentImageDirectory==HTuple("")))
    {
      hv_CurrentImageDirectory = ".";
    }
    GetSystem("image_dir", &hv_HalconImages);
    GetSystem("operating_system", &hv_OS);
    if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
    {
      hv_HalconImages = hv_HalconImages.TupleSplit(";");
    }
    else
    {
      hv_HalconImages = hv_HalconImages.TupleSplit(":");
    }
    hv_Directories = hv_CurrentImageDirectory;
    {
    HTuple end_val41 = (hv_HalconImages.TupleLength())-1;
    HTuple step_val41 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val41, step_val41); hv_Index += step_val41)
    {
      hv_Directories = hv_Directories.TupleConcat((HTuple(hv_HalconImages[hv_Index])+"/")+hv_CurrentImageDirectory);
    }
    }
    TupleStrlen(hv_Directories, &hv_Length);
    TupleGenConst(hv_Length.TupleLength(), 0, &hv_NetworkDrive);
    if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
    {
      {
      HTuple end_val47 = (hv_Length.TupleLength())-1;
      HTuple step_val47 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val47, step_val47); hv_Index += step_val47)
      {
        if (0 != ((HTuple(hv_Directories[hv_Index]).TupleStrlen())>1))
        {
          TupleStrFirstN(HTuple(hv_Directories[hv_Index]), 1, &hv_Substring);
          if (0 != (HTuple(hv_Substring==HTuple("//")).TupleOr(hv_Substring==HTuple("\\\\"))))
          {
            hv_NetworkDrive[hv_Index] = 1;
          }
        }
      }
      }
    }
    hv_ImageFilesTmp = HTuple();
    {
    HTuple end_val57 = (hv_Directories.TupleLength())-1;
    HTuple step_val57 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val57, step_val57); hv_Index += step_val57)
    {
      FileExists(HTuple(hv_Directories[hv_Index]), &hv_FileExists);
      if (0 != hv_FileExists)
      {
        ListFiles(HTuple(hv_Directories[hv_Index]), HTuple("files").TupleConcat(hv_Options), 
            &hv_AllFiles);
        hv_ImageFilesTmp = HTuple();
        {
        HTuple end_val62 = (hv_Extensions.TupleLength())-1;
        HTuple step_val62 = 1;
        for (hv_i=0; hv_i.Continue(end_val62, step_val62); hv_i += step_val62)
        {
          TupleRegexpSelect(hv_AllFiles, ((".*"+HTuple(hv_Extensions[hv_i]))+"$").TupleConcat("ignore_case"), 
              &hv_Selection);
          hv_ImageFilesTmp = hv_ImageFilesTmp.TupleConcat(hv_Selection);
        }
        }
        TupleRegexpReplace(hv_ImageFilesTmp, (HTuple("\\\\").Append("replace_all")), 
            "/", &hv_ImageFilesTmp);
        if (0 != (HTuple(hv_NetworkDrive[hv_Index])))
        {
          TupleRegexpReplace(hv_ImageFilesTmp, (HTuple("//").Append("replace_all")), 
              "/", &hv_ImageFilesTmp);
          hv_ImageFilesTmp = "/"+hv_ImageFilesTmp;
        }
        else
        {
          TupleRegexpReplace(hv_ImageFilesTmp, (HTuple("//").Append("replace_all")), 
              "/", &hv_ImageFilesTmp);
        }
        break;
      }
    }
    }
    //Concatenate the output image paths.
    (*hv_ImageFiles) = (*hv_ImageFiles).TupleConcat(hv_ImageFilesTmp);
  }
  }
  return;
}

// Local procedures 
// Chapter: 自动建模
// Short Description: 自动建模 
void InnerHalconAutoCreateAlgMode (HObject ho_hCheckImg, HObject *ho_hShowReg, HObject *ho_hModelImg, 
    HObject *ho_hModelReg, HTuple hv_htParamVaule, HTuple hv_htResolution, HTuple hv_htHalconHandle, 
    HTuple *hv_htParamVauleNew, HTuple *hv_htCheckResultCode, HTuple *hv_htHalconHandleNew, 
    HTuple *hv_htState)
{

  // Local iconic variables
    HObject ho_hCheckImgX, ho_hCheckImgY,ho_hCheckImgZ, ho_Region, ho_ConnectedRegions, ho_SelectedRegions;
    HObject ho_RegionUnion, ho_ImageReduced;

  // Local control variables
    HTuple hv_htResolutionX, hv_htResolutionY, hv_Number;

  //简化系统，自动创建模板
  //作者：张波
  //版本：V1.0
  //**********************************************
  (*hv_htState) = 0;
  hv_htResolutionX = ((const HTuple&)hv_htResolution)[0];
  hv_htResolutionY = ((const HTuple&)hv_htResolution)[1];
  (*hv_htCheckResultCode) = "";

  CountChannels(ho_hCheckImg, &hv_Number);
  int n = hv_Number.I();
  if (0 != (hv_Number==3))
  {

   // hv_htSelectChannel = ((const HTuple&)hv_htParamVaule)[0];
      Decompose3(ho_hCheckImg, &ho_hCheckImgX, &ho_hCheckImgY, &ho_hCheckImgZ);

  }
  else
  {
    (*hv_htState) = 1;
    return;
  }

  //开始
  double maxValue, minValue;
  minValue = hv_htParamVaule[1].D();
  maxValue = hv_htParamVaule[2].D();
  Threshold(ho_hCheckImgZ, &ho_Region, minValue, maxValue);

  Connection(ho_Region, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 150, 99999);

  Union1(ho_SelectedRegions, &ho_RegionUnion);
  FillUp(ho_RegionUnion, ho_hShowReg);
  CopyObj(*ho_hShowReg, ho_hModelReg, 1, 1);
  ReduceDomain(ho_hCheckImgZ, *ho_hShowReg, ho_hModelImg);

  return;
}

void InnerHalconAutoLearnAlgMode (HObject ho_hModelImg, HObject ho_hCheckImg, HObject *ho_hModelImgNew, 
    HTuple *hv_htState)
{

  // Local iconic variables

  //简化系统，误报学习
  //作者：张波
  //版本：V1.0
  //**********************************************
  (*hv_htState) = 2;

  //
  return;
}

void InnerHalconInitHandle (HTuple hv_ParamVaule, HTuple hv_HalconHandle, HTuple *hv_HalconHandleNew, 
    HTuple *hv_htState)
{

  // Local iconic variables

  //简化系统，halcon句柄初始化
  //作者：张波
  //版本：V1.0
  //**********************************************

  (*hv_htState) = 0;
  //HALCON 句柄初始化
  if (0 != (hv_HalconHandle!=-1))
  {
    //clear_bar_code_model (HalconHandle)
    hv_HalconHandle = -1;
  }

  //create_bar_code_model ([], [], HalconHandleNew)
  //set_bar_code_param (HalconHandleNew, 'persistence', 1)
  //set_bar_code_param (HalconHandleNew, 'element_size_min', 1.2)
  //set_bar_code_param (HalconHandleNew, 'meas_thresh', 0.2)
  //set_bar_code_param (HalconHandleNew, 'element_size_max', 40)

  return;

}

void InnerHalconReadHtParam (HTuple hv_ImgChannels, HTuple *hv_ParamProp, HTuple *hv_ParamName, 
    HTuple *hv_ParamVaule, HTuple *hv_ParamMeaning, HTuple *hv_ParamType, HTuple *hv_ParamMinVaule, 
    HTuple *hv_ParamMaxVaule, HTuple *hv_ParamStep, HTuple *hv_ParamChildNames, HTuple *hv_htState)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ParamChildName1, hv_ParamChildName2;
  HTuple  hv_ParamChildName3, hv_ParamChildName4, hv_Length1;
  HTuple  hv_Length2, hv_Length3, hv_Length4, hv_Length5;
  HTuple  hv_Length6, hv_Length7, hv_Length8, hv_Length9;

  //简化系统，检测参数初始化
  //作者：张波
  //版本：V1.0
  //**********************************************
  (*hv_htState) = 0;
  //总共9类 4组参数

  //1-[属性] 只读
  //属性含义说明
  //1 - 自动建模所需参数，属性参数
  //0 - 检测所需参数（标准参数、检测参数）
  (*hv_ParamProp).Clear();
  (*hv_ParamProp)[0] = 1;
  (*hv_ParamProp)[1] = 1;
  (*hv_ParamProp)[2] = 1;
  //(*hv_ParamProp)[4] = 0;

  //2-[名称] 只读
  (*hv_ParamName).Clear();
  (*hv_ParamName)[0] = "通道";//'通道'
      //"\315\250\265\300";
  (*hv_ParamName)[1] = "低阈值";//'黑盒'
     // "\272\332\272\320";
  (*hv_ParamName)[2] = "高阈值";//'标准长度'
     // "\261\352\327\274\263\244\266\310";
  //(*hv_ParamName)[4] = "测试";//'长度公差'
      //"\263\244\266\310\271\253\262\356";

  //3-[数值] 读写
  (*hv_ParamVaule).Clear();
  (*hv_ParamVaule)[0] = 0;
  (*hv_ParamVaule)[1] = 0;
  (*hv_ParamVaule)[2] = 100;
  //彩色图像时，默认选G通道
  if (0 != (hv_ImgChannels==3))
  {
    (*hv_ParamVaule)[0] = 2;
  }

  //4-[含义] 只读
  (*hv_ParamMeaning).Clear();
  (*hv_ParamMeaning)[0] = //'0:原始通道；1:R;2:G;3:B'
      "0:\324\255\312\274\315\250\265\300\243\2731:R;2:G;3:B";
  (*hv_ParamMeaning)[1] = "引脚最小深度值";//'0:白盒;1:黑盒'
      //"0:\260\327\272\320;1:\272\332\272\320";
  (*hv_ParamMeaning)[2] = "引脚最大深度值";//'单位：mm'
      //"\265\245\316\273\243\272mm";

  //5-[类型]只读
  //0-BOOL
  //1-整型
  //2-浮点型
  //3-枚举 下拉控件
  (*hv_ParamType).Clear();
  (*hv_ParamType)[0] = 3;
  (*hv_ParamType)[1] = 2;
  (*hv_ParamType)[2] = 2;

  //6-[最小值]只读
  (*hv_ParamMinVaule).Clear();
  (*hv_ParamMinVaule)[0] = 0;
  (*hv_ParamMinVaule)[1] = 0;
  (*hv_ParamMinVaule)[2] = 0;

  //7-[最大值]只读
  (*hv_ParamMaxVaule).Clear();
  (*hv_ParamMaxVaule)[0] = 1;
  (*hv_ParamMaxVaule)[1] = 10000;
  (*hv_ParamMaxVaule)[2] = 10000;
  if (0 != (hv_ImgChannels==3))
  {
    (*hv_ParamMaxVaule)[0] = 3;
  }

  //8-[步长]只读
  (*hv_ParamStep).Clear();
  (*hv_ParamStep)[0] = 1;
  (*hv_ParamStep)[1] = 1;
  (*hv_ParamStep)[2] = 0.1;

  //9-[多子参数名]只读 下拉控件使用
  if (0 != (hv_ImgChannels==3))
  {
    hv_ParamChildName1 = //'原始通道;R通道;G通道;B通道'
      "\324\255\312\274\315\250\265\300;R\315\250\265\300;G\315\250\265\300;B\315\250\265\300";
  }
  else
  {
    hv_ParamChildName1 = //'原始通道'
      "\324\255\312\274\315\250\265\300";
  }
  hv_ParamChildName2 = "";
  hv_ParamChildName3 = "";
  hv_ParamChildName4 = "";
  (*hv_ParamChildNames).Clear();
  (*hv_ParamChildNames).Append(hv_ParamChildName1);
  (*hv_ParamChildNames).Append(hv_ParamChildName2);
  (*hv_ParamChildNames).Append(hv_ParamChildName3);
  (*hv_ParamChildNames).Append(hv_ParamChildName4);

  //参数个数校验
  TupleLength((*hv_ParamProp), &hv_Length1);
  TupleLength((*hv_ParamName), &hv_Length2);
  TupleLength((*hv_ParamVaule), &hv_Length3);
  TupleLength((*hv_ParamMeaning), &hv_Length4);
  TupleLength((*hv_ParamType), &hv_Length5);
  TupleLength((*hv_ParamMinVaule), &hv_Length6);
  TupleLength((*hv_ParamMaxVaule), &hv_Length7);
  TupleLength((*hv_ParamStep), &hv_Length8);
  TupleLength((*hv_ParamChildNames), &hv_Length9);
  if (0 != ((((((((((8*hv_Length1)-hv_Length2)-hv_Length3)-hv_Length4)-hv_Length5)-hv_Length6)-hv_Length7)-hv_Length8)-hv_Length9)==0))
  {

  }
  else
  {
    //个数不对
    (*hv_htState) = 1;
    // stop(...); only in hdevelop
  }

  return;
}

 //Chapter: 内部检测
 //Short Description: 内部检测 
void InnerHalconSingleCheck (HObject ho_hCheckImg, HObject ho_hModelImg, HObject ho_hModelReg, 
    HObject *ho_hShowReg, HObject *ho_hErrorReg, HTuple hv_htParamVaule, HTuple hv_htResolution, 
    HTuple hv_htHalconHandle, HTuple hv_htExpectedCode, HTuple *hv_htErrorInfor, 
    HTuple *hv_htCheckResultCode, HTuple *hv_htState)
{

  // Local iconic variables
  HObject  ho_hCheckImgNew, ho_hCheckImgR, ho_hCheckImgG;
  HObject  ho_hCheckImgB, ho_Region, ho_Region1, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionErosion, ho_Rectangle;
  HObject  ho_ImageReduced, ho_ImageMedian, ho_ImageSub, ho_ImageSub1;
  HObject  ho_ImageMax, ho_ImageMedian1, ho_ImageMedian2, ho_RegionDynThresh;
  HObject  ho_RegionClosing, ho_ConnectedRegions1, ho_ObjectSelected;

  // Local control variables
  HTuple  hv_htResolutionX, hv_htResolutionY, hv_Number;
  HTuple  hv_htSelectChannel, hv_htbIsBlack, hv_htStandrdLength;
  HTuple  hv_htLengthThr, hv_Width, hv_Height, hv_UsedThreshold;
  HTuple  hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2;
  HTuple  hv_Mean, hv_Deviation, hv_Row1, hv_Column1, hv_Phi1;
  HTuple  hv_Length11, hv_Length21, hv_Length, hv_ErrorMaxLength;
  HTuple  hv_Index, hv_Row2, hv_Column2, hv_Phi2, hv_Length12;
  HTuple  hv_Length22, hv_CheckLength, hv_ErrorLength;

  //简化系统，独立检测
  //作者：张波
  //版本：V1.0
  //**********************************************
  (*hv_htState) = 0;

  GenEmptyObj(&(*ho_hShowReg));
  GenEmptyObj(&(*ho_hErrorReg));
  TupleGenConst(3, 0, &(*hv_htErrorInfor));
  (*hv_htErrorInfor)[2] = //'正常'
      "\325\375\263\243";
  (*hv_htCheckResultCode) = "";

  hv_htResolutionX = ((const HTuple&)hv_htResolution)[0];
  hv_htResolutionY = ((const HTuple&)hv_htResolution)[1];
  //***************************************
  //检测部分
  GenEmptyObj(&ho_hCheckImgNew);
  CountObj(ho_hCheckImg, &hv_Number);

  if (0 != (hv_Number==3))
  {
    hv_htSelectChannel = ((const HTuple&)hv_htParamVaule)[0];
    if (0 != (hv_htSelectChannel==0))
    {
      SelectObj(ho_hCheckImg, &ho_hCheckImgR, 1);
      SelectObj(ho_hCheckImg, &ho_hCheckImgG, 2);
      SelectObj(ho_hCheckImg, &ho_hCheckImgB, 3);
      Compose3(ho_hCheckImgR, ho_hCheckImgG, ho_hCheckImgB, &ho_hCheckImgNew);
    }
    else if (0 != (hv_htSelectChannel==1))
    {
      SelectObj(ho_hCheckImg, &ho_hCheckImgNew, 1);
    }
    else if (0 != (hv_htSelectChannel==2))
    {
      SelectObj(ho_hCheckImg, &ho_hCheckImgNew, 2);
    }
    else if (0 != (hv_htSelectChannel==3))
    {
      SelectObj(ho_hCheckImg, &ho_hCheckImgNew, 3);
    }

  }
  else if (0 != (hv_Number==1))
  {
    ho_hCheckImgNew = ho_hCheckImg;
  }
  else
  {
    (*hv_htState) = 1;
    return;
  }

  //修改开始
  //***************************************
  hv_htbIsBlack = ((const HTuple&)hv_htParamVaule)[1];
  hv_htStandrdLength = ((const HTuple&)hv_htParamVaule)[2];
  hv_htLengthThr = ((const HTuple&)hv_htParamVaule)[3];

  GetImageSize(ho_hCheckImgNew, &hv_Width, &hv_Height);
  BinaryThreshold(ho_hCheckImgNew, &ho_Region, "max_separability", "light", &hv_UsedThreshold);
  Threshold(ho_hCheckImgNew, &ho_Region1, hv_UsedThreshold-25, 255);
  Connection(ho_Region1, &ho_ConnectedRegions);
  SelectShapeStd(ho_ConnectedRegions, &ho_SelectedRegions, "max_area", 70);
  if (0 != (hv_htbIsBlack==1))
  {
    ErosionCircle(ho_SelectedRegions, &ho_RegionErosion, 3.5);
  }
  else
  {
    ErosionCircle(ho_SelectedRegions, &ho_RegionErosion, 83.5);
  }

  SmallestRectangle2(ho_RegionErosion, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
      &hv_Length2);
  GenRectangle2(&ho_Rectangle, hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2);

  ReduceDomain(ho_hCheckImgNew, ho_Rectangle, &ho_ImageReduced);
  MedianRect(ho_ImageReduced, &ho_ImageMedian, 35, 35);
  SubImage(ho_ImageReduced, ho_ImageMedian, &ho_ImageSub, 1, 128);
  Intensity(ho_Rectangle, ho_ImageSub, &hv_Mean, &hv_Deviation);
  SubImage(ho_ImageSub, ho_ImageSub, &ho_ImageSub1, 1, hv_Mean-(1.5*hv_Deviation));
  MaxImage(ho_ImageSub, ho_ImageSub1, &ho_ImageMax);

  MedianRect(ho_ImageMax, &ho_ImageMedian1, 3, 3);
  MedianRect(ho_ImageMedian1, &ho_ImageMedian2, 25, 25);
  DynThreshold(ho_ImageMedian1, ho_ImageMedian2, &ho_RegionDynThresh, 6, "light");
  ClosingRectangle1(ho_RegionDynThresh, &ho_RegionClosing, 21, 1);
  Connection(ho_RegionClosing, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &(*ho_hShowReg), "width", "and", hv_Width/3, 
      99999999);
  SmallestRectangle2((*ho_hShowReg), &hv_Row1, &hv_Column1, &hv_Phi1, &hv_Length11, 
      &hv_Length21);
  TupleLength(hv_Phi1, &hv_Length);
  if (0 != (hv_Length!=3))
  {
    (*ho_hErrorReg) = (*ho_hShowReg);
    (*hv_htErrorInfor)[0] = 1;
    (*hv_htErrorInfor)[1] = 200;
    (*hv_htErrorInfor)[2] = //'胶线根数不对'
      "\275\272\317\337\270\371\312\375\262\273\266\324";

    return;
  }
  else
  {
    hv_ErrorMaxLength = 0;
    {
    HTuple end_val85 = hv_Length;
    HTuple step_val85 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val85, step_val85); hv_Index += step_val85)
    {
      SelectObj((*ho_hShowReg), &ho_ObjectSelected, hv_Index);
      SmallestRectangle2(ho_ObjectSelected, &hv_Row2, &hv_Column2, &hv_Phi2, &hv_Length12, 
          &hv_Length22);
      hv_CheckLength = (hv_Length12*2)*hv_htResolutionX;
      hv_ErrorLength = hv_CheckLength-hv_htStandrdLength;
      if (0 != ((hv_ErrorLength.TupleAbs())>hv_htLengthThr))
      {
        ConcatObj((*ho_hErrorReg), ho_ObjectSelected, &(*ho_hErrorReg));
        if (0 != ((hv_ErrorLength.TupleAbs())>hv_ErrorMaxLength))
        {
          hv_ErrorMaxLength = hv_ErrorLength.TupleAbs();
        }
      }
    }
    }
    CountObj((*ho_hErrorReg), &hv_Number);
    if (0 != (hv_Number>0))
    {
      (*hv_htErrorInfor)[0] = 2;
      (*hv_htErrorInfor)[1] = hv_ErrorMaxLength;
      (*hv_htErrorInfor)[2] = (//'胶线长短差异：'
      "\275\272\317\337\263\244\266\314\262\356\322\354\243\272"+hv_ErrorMaxLength)+" mm";

      return;
    }
  }

  //修改结束
  return;
}

//生成3D相机参数
void GenCamParAreaScanDivision(HTuple hv_Focus, HTuple hv_Kappa, HTuple hv_Sx,
    HTuple hv_Sy, HTuple hv_Cx, HTuple hv_Cy, HTuple hv_ImageWidth, HTuple hv_ImageHeight,
    HTuple *hv_CameraParam)
{

    (*hv_CameraParam).Clear();
    (*hv_CameraParam)[0] = "area_scan_division";
    (*hv_CameraParam).Append(hv_Focus);
    (*hv_CameraParam).Append(hv_Kappa);
    (*hv_CameraParam).Append(hv_Sx);
    (*hv_CameraParam).Append(hv_Sy);
    (*hv_CameraParam).Append(hv_Cx);
    (*hv_CameraParam).Append(hv_Cy);
    (*hv_CameraParam).Append(hv_ImageWidth);
    (*hv_CameraParam).Append(hv_ImageHeight);
    return;
}

void InnerHalconSingleCheck(HTuple hv_SurfaceModelIDLarge, const HObject& hImgSrc, HTuple *hv_htState)
{
    HTuple htState, hv_ObjectModel3DTarget, hv_Pose, hv_CameraParam, hv_Pose2, hv_Score1;
    HTuple hv_SurfaceMatchingResultID, channels;
    HObject  ho_X, ho_Y, ho_Z;
    CreatePose(-0.00, 0.00, 0.0, 0.0, 0.0, 0.0, "Rp+T", "gba", "point", &hv_Pose);
    GenCamParAreaScanDivision(0.016, 0, 5e-6, 5e-6, 1280, 960, 2560, 1920, &hv_CameraParam);

    CountChannels(hImgSrc, &channels);
    if (channels != 3)
    {
        (*hv_htState) = 1;
        return;
    }

    //Compose3(ho_X, ho_Y, ho_Z, &hImgSrc);
    XyzToObjectModel3d(ho_X, ho_Y, ho_Z, &hv_ObjectModel3DTarget);
    FindSurfaceModel(hv_SurfaceModelIDLarge, hv_ObjectModel3DTarget, 0.05, 1, 0, "true", "num_matches",
        1, &hv_Pose2, &hv_Score1, &hv_SurfaceMatchingResultID);

    {
        HTuple hv_i, hv_CPose, hv_HomMat3D, hv_ObjectModel3DAffineTrans;
        HObject ho_X1, ho_Y1, ho_Z1, ho_ObjectSelect;
        HTuple hv_ObjectModel3DReduced, hv_ObjectModel3DOut, hv_Primitive_param;
        HTuple  hv_ObjectModel3DPlane, hv_GenParamValue, hv_Mean1, hv_Deviation1, hv_Min1, hv_Max1;
        HTuple end_val87 = (hv_Score1.TupleLength()) - 1;
        HTuple step_val87 = 1;
        for (hv_i = 0; hv_i.Continue(end_val87, step_val87); hv_i += step_val87)
        {
            hv_CPose = hv_Pose2.TupleSelectRange(hv_i * 7, (hv_i * 7) + 6);
            PoseToHomMat3d(hv_CPose, &hv_HomMat3D);
            AffineTransObjectModel3d(hv_ObjectModel3DTarget, hv_HomMat3D, &hv_ObjectModel3DAffineTrans);
            ObjectModel3dToXyz(&ho_X1, &ho_Y1, &ho_Z1, hv_ObjectModel3DAffineTrans, "cartesian",
                hv_CameraParam, hv_CPose);
            ReduceObjectModel3dByView(ho_Z1, hv_ObjectModel3DTarget, hv_CameraParam, hv_CPose,
                &hv_ObjectModel3DReduced);

            FitPrimitivesObjectModel3d(hv_ObjectModel3DReduced, (HTuple("primitive_type").Append("fitting_algorithm")),
                (HTuple("plane").Append("least_squares_tukey")), &hv_ObjectModel3DOut);
            GetObjectModel3dParams(hv_ObjectModel3DOut, "primitive_parameter_pose", &hv_Primitive_param);
            GenPlaneObjectModel3d(hv_Primitive_param, HTuple(), HTuple(), &hv_ObjectModel3DPlane);
            DistanceObjectModel3d(hv_ObjectModel3DReduced, hv_ObjectModel3DPlane, HTuple(), 0,
                "distance_to", "primitive");
            GetObjectModel3dParams(hv_ObjectModel3DReduced, "&distance", &hv_GenParamValue);
            TupleMean(hv_GenParamValue, &hv_Mean1);
            TupleDeviation(hv_GenParamValue, &hv_Deviation1);
            TupleMin(hv_GenParamValue, &hv_Min1);
            TupleMax(hv_GenParamValue, &hv_Max1);

        }
    }
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_CheckReg, ho_ImageReduced;
  HObject  ho_CheckImg, ho_ImageR, ho_ImageG, ho_ImageB, ho_ObjectsConcat;
  HObject  ho_ModelCheckImg, ho_ShowReg, ho_ModelImg, ho_ModelReg;
  HObject  ho_Image1, ho_ImageReduced1, ho_CheckImage0, ho_CheckImage;
  HObject  ho_ErrorReg;

  // Local control variables
  HTuple  hv_WindowHandle, hv_ImgChannels, hv_htState;
  HTuple  hv_ParamProp, hv_ParamName, hv_ParamVaule, hv_ParamMeaning;
  HTuple  hv_ParamType, hv_ParamMinVaule, hv_ParamMaxVaule;
  HTuple  hv_ParamStep, hv_ParamChildNames, hv_HalconHandle;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Channels;
  HTuple  hv_Resolution, hv_CheckResultCode, hv_Indices, hv_ImageFiles;
  HTuple  hv_Length, hv_Index, hv_bLearn, hv_htExpectedCode;
  HTuple  hv_htErrorInfor, hv_Length1;

  //*********************************************
  //简化系统，算法例程框架
  //作者：张波
  //版本：V1.0
  //**********************************************
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    hv_WindowHandle = HDevWindowStack::GetActive();
  ReadImage(&ho_Image, //'F:/产品线/社会/2017年及之前/当纳利/手机盒胶线/图像/0925-006/Camera0/1.bmp'
      "F:/\262\372\306\267\317\337/\311\347\273\341/2017\304\352\274\260\326\256\307\260/\265\261\304\311\300\373/\312\326\273\372\272\320\275\272\317\337/\315\274\317\361/0925-006/Camera0/1.bmp");
  CountChannels(ho_Image, &hv_ImgChannels);
  //函数状态
  //0-正常，1-异常，2-不支持
  hv_htState = 0;

  //参数部分
  //**********************************************
  hv_ParamProp = HTuple();
  hv_ParamName = HTuple();
  hv_ParamVaule = HTuple();
  hv_ParamMeaning = HTuple();
  hv_ParamType = HTuple();
  hv_ParamMinVaule = HTuple();
  hv_ParamMaxVaule = HTuple();
  hv_ParamStep = HTuple();
  hv_ParamChildNames = HTuple();
  //原始参数读取
  hv_htState = 0;
  InnerHalconReadHtParam(hv_ImgChannels, &hv_ParamProp, &hv_ParamName, &hv_ParamVaule, 
      &hv_ParamMeaning, &hv_ParamType, &hv_ParamMinVaule, &hv_ParamMaxVaule, &hv_ParamStep, 
      &hv_ParamChildNames, &hv_htState);
  if (0 != (hv_htState>0))
  {
    //函数异常
    // stop(...); only in hdevelop
  }
  //halcon句柄初始化
  hv_HalconHandle = -1;

  hv_htState = 0;
  InnerHalconInitHandle(hv_ParamVaule, hv_HalconHandle, &hv_HalconHandle, &hv_htState);
  if (0 != (hv_htState>0))
  {
    //函数异常
    // stop(...); only in hdevelop
  }
  //Vector
  //VectParam := {ParamProp,ParamName,ParamVaule,ParamMeaning,ParamType,ParamMinVaule,ParamMinVaule,ParamStep}
  //数组
  //Param := [ParamProp,ParamName,ParamVaule,ParamMeaning,ParamType,ParamMinVaule,ParamMinVaule,ParamStep]

  //建模部分
  //**********************************************
  //mirror_image (Image, Image, 'row')
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());

  DrawRectangle1(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  GenRectangle1(&ho_CheckReg, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
  ReduceDomain(ho_Image, ho_CheckReg, &ho_ImageReduced);
  CropDomain(ho_ImageReduced, &ho_CheckImg);

  CountChannels(ho_CheckImg, &hv_Channels);
  if (0 != (hv_Channels==3))
  {
    Decompose3(ho_CheckImg, &ho_ImageR, &ho_ImageG, &ho_ImageB);
    ConcatObj(ho_ImageR, ho_ImageG, &ho_ObjectsConcat);
    ConcatObj(ho_ObjectsConcat, ho_ImageB, &ho_ModelCheckImg);
  }
  else if (0 != (hv_Channels==1))
  {
    ho_ModelCheckImg = ho_CheckImg;
  }

  //**************************************
  //由系统传入分辨率
  hv_Resolution.Clear();
  hv_Resolution[0] = 0.1;
  hv_Resolution[1] = 0.1;

  //码类识别结果
  TupleGenConst(0, 0, &hv_CheckResultCode);

  //自动建模函数
  GenEmptyObj(&ho_ShowReg);
  //存储模板图像、区域
  GenEmptyObj(&ho_ModelImg);
  GenEmptyObj(&ho_ModelReg);

  hv_htState = 0;
  InnerHalconAutoCreateAlgMode(ho_ModelCheckImg, &ho_ShowReg, &ho_ModelImg, &ho_ModelReg, 
      hv_ParamVaule, hv_Resolution, hv_HalconHandle, &hv_ParamVaule, &hv_CheckResultCode, 
      &hv_HalconHandle, &hv_htState);
  if (0 != (hv_htState>0))
  {
    //函数异常
    // stop(...); only in hdevelop
  }

  if (HDevWindowStack::IsOpen())
    DispObj(ho_ModelCheckImg, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ShowReg, HDevWindowStack::GetActive());
  TupleFind(hv_CheckResultCode, "", &hv_Indices);
  if (0 != (hv_Indices!=0))
  {
    disp_message(hv_WindowHandle, //'码号：'
      "\302\353\272\305\243\272"+hv_CheckResultCode, 
        "window", 50, 25, "black", "true");
  }
  // stop(...); only in hdevelop
  //检测部分
  //*****************************************
  list_image_files(//'F:/产品线/社会/2017年及之前/当纳利/手机盒胶线/图像/0925-006/Camera0'
      "F:/\262\372\306\267\317\337/\311\347\273\341/2017\304\352\274\260\326\256\307\260/\265\261\304\311\300\373/\312\326\273\372\272\320\275\272\317\337/\315\274\317\361/0925-006/Camera0", 
      "default", HTuple(), &hv_ImageFiles);
  TupleLength(hv_ImageFiles, &hv_Length);
  //******************************
  //有模板图像或区域时，读取模板图像或区域
  //检测参数
  {
  HTuple end_val99 = hv_Length;
  HTuple step_val99 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val99, step_val99); hv_Index += step_val99)
  {
    ReadImage(&ho_Image1, HTuple(hv_ImageFiles[hv_Index-1]));
    //mirror_image (Image1, Image1, 'row')
    ReduceDomain(ho_Image1, ho_CheckReg, &ho_ImageReduced1);
    CropDomain(ho_ImageReduced1, &ho_CheckImage0);
    CountChannels(ho_CheckImage0, &hv_Channels);
    if (0 != (hv_Channels==3))
    {
      Decompose3(ho_CheckImage0, &ho_ImageR, &ho_ImageG, &ho_ImageB);
      ConcatObj(ho_ImageR, ho_ImageG, &ho_ObjectsConcat);
      ConcatObj(ho_ObjectsConcat, ho_ImageB, &ho_CheckImage);
    }
    else if (0 != (hv_Channels==1))
    {
      ho_CheckImage = ho_CheckImage0;
    }
    //******************************************
    //内部检测函数
    //误报学习
    hv_htState = 0;
    hv_bLearn = 0;
    if (0 != (hv_bLearn==1))
    {
      InnerHalconAutoLearnAlgMode(ho_ModelImg, ho_CheckImage, &ho_ModelImg, &hv_htState);
      if (0 != (hv_htState>0))
      {
        //函数异常
        // stop(...); only in hdevelop
      }
    }
    //输入预期号
    hv_htExpectedCode = "";
    //检测获取检测区域
    GenEmptyObj(&ho_ShowReg);
    //检测获取错误区域
    GenEmptyObj(&ho_ErrorReg);
    //码类识别结果
    TupleGenConst(0, 0, &hv_CheckResultCode);

    //错误参数输出
    TupleGenConst(0, 0, &hv_htErrorInfor);
    //htErrorInfor 包含以下三个信息
    //1-htErrorType 错误类型 0-缺 1-错号 2-...
    //2-htErrorGrade 错误级别
    //3-htErrorDescrip 错误描述
    hv_htState = 0;
    InnerHalconSingleCheck(ho_CheckImage, ho_ModelImg, ho_ModelReg, &ho_ShowReg, 
        &ho_ErrorReg, hv_ParamVaule, hv_Resolution, hv_HalconHandle, hv_htExpectedCode, 
        &hv_htErrorInfor, &hv_CheckResultCode, &hv_htState);
    if (0 != (hv_htState>0))
    {
      //函数异常
      // stop(...); only in hdevelop
    }
    if (HDevWindowStack::IsOpen())
      DispObj(ho_CheckImage, HDevWindowStack::GetActive());
    if (0 != (HTuple(hv_htErrorInfor[0])>0))
    {
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ErrorReg, HDevWindowStack::GetActive());

      disp_message(hv_WindowHandle, //'结果：'
      "\275\341\271\373\243\272"+HTuple(hv_htErrorInfor[2]), 
          "window", 80, 25, "black", "true");

      TupleFind(hv_CheckResultCode, "", &hv_Indices);
      if (0 != (hv_Indices!=0))
      {
        TupleStrlen(hv_htExpectedCode, &hv_Length1);
        if (0 != (hv_Length1>0))
        {
          disp_message(hv_WindowHandle, //'预期号：'
      "\324\244\306\332\272\305\243\272"+hv_htExpectedCode, 
              "window", 20, 25, "black", "true");
        }
        disp_message(hv_WindowHandle, //'识别号：'
      "\312\266\261\360\272\305\243\272"+hv_CheckResultCode, 
            "window", 50, 25, "black", "true");
      }
      // stop(...); only in hdevelop
    }
    else
    {
      if (HDevWindowStack::IsOpen())
        DispObj(ho_CheckImage, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"green");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ShowReg, HDevWindowStack::GetActive());

      disp_message(hv_WindowHandle, //'结果：'
      "\275\341\271\373\243\272"+HTuple(hv_htErrorInfor[2]), 
          "window", 80, 25, "black", "true");

      TupleFind(hv_CheckResultCode, "", &hv_Indices);
      if (0 != (hv_Indices!=0))
      {
        TupleStrlen(hv_htExpectedCode, &hv_Length1);
        if (0 != (hv_Length1>0))
        {
          disp_message(hv_WindowHandle, //'预期号：'
      "\324\244\306\332\272\305\243\272"+hv_htExpectedCode, 
              "window", 20, 25, "black", "true");
        }

        disp_message(hv_WindowHandle, //'识别号：'
      "\312\266\261\360\272\305\243\272"+hv_CheckResultCode, 
            "window", 50, 25, "black", "true");
      }
      // stop(...); only in hdevelop
    }

  }
  }
  //释放
  if (0 != (hv_HalconHandle!=-1))
  {
    //clear_bar_code_model (HalconHandle)
    hv_HalconHandle = -1;
  }


}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
    XInitThreads();
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
   // SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


